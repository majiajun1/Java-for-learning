# 业务讲解 笔记

申请信息 讯飞初审 -->没问题  传给第三方接口  --->再传给客户端

和第三方对接口 

 

第三方机构 数据保密性很强

用户申报信息-->审核基础信息，放在公司内部数据库查信息-->通过后，申报表 放在对外数据库--->第三方定时从外部数据库拉数据到内部服务器--->审核-->审核结果（申报表）放在第三方对外数据库---->we 拉数据    保存我们对内数据库---->用户看到申报流程





数据越拉越多    Elasticsearch  优化负载                  

申报信息有筛选条件  还有图片  十几个   数据量大访问会大    一千万条数据 十几个筛选条件      



通过定时任务 迁徙到ES上面去      ES只存有没有提交图片的状态（只存有无填写的状态） 只关联申报信息的ID      详情的按钮  点了详情再走组件索引   没走索引查了几十秒



redis 广告接入  收集用户推广 插入广告   redis oom问题     定时拉取广告ID（每天的） key 加了今天的日期  没有设置过期时间  广告ID是一个json   导致越存越多 OOM  

通过日期来匹配广告ID        通过今天的日期来匹配到广告ID      然后还要去平台根据ID拉取请求一次

做成异步   线程池   future对象 get 方法（有超时参数）  广告超时则不插入



申报表的ID来查   

办结表有那条ID  那就是办结了  无状态

库表交换 不愿意开放接口 保证安全  



定时任务拉数据 往两边扩展一点  有重叠数据 不会漏      不重复就可以插入进去         防止定时任务漏东西  回滚 再拉



sql调优





报表 申报表 申报失败表 审核中的表  可以多线程的查      



年龄段分组  所处行业的分组    联合索引 新建B+树来组合查询    最左匹配原则  按照组合查询的索引的顺序 最左匹配   例如(A,B,C)的联合索引   那sql语句只能 A AB  ABC     不能BA AC  BC 和单列  这样用不到组合查询   跳过中间条件来查的话 只会用到部分的组合索引 然后再单列索引（无法加速）



MQ消息提示 通知客服审核 功能         前端页面弹东西                

  MQ把数据同步到ES ?

   用户创建申报信息之后    到数据库  然后返回主键ID   MQ异步发主键ID      用户拿到主键ID     去表里面查一次  保证表里面有数据  再把数据迁移到ES（存状态） 异步



> 文件交换平台

 推文件 推到第三方文件服务器   第三方去扫  

用户提交文件 上传到系统 返回文件的路径    路径存在我们的数据库  关联申报ID     再通过库表交换的形式把文件读出来



文件是一个压缩包形式  先到OSS系统  返回地址   解析文件成几份  因为需要的文件不一样  **责任链模式**   放在公开服务器的某个目录下面      拆出来后  再打包压缩包 拿过去审核   把结果放在中间库  我们拉结果   那办结表会有几条数据（就是反应哪个文件传错了 全部传对那就没事）     （理解成不同的人负责审的文件不一样）  （定时任务）



刚开始是大的压缩包  后面就三个   第三方扫文件  都关联申报ID     文件名上带申报ID就好了



定时任务抢锁 往前推半个小时  查申报表       获取申报ID 和文件地址     再去扫数据库获取文件   （解压 解析  要改名 加申报ID  文件的格式）    分别打包放到对外服务器上面  



**总结版：**该系统实现了一个文件上传与审核的流程，用户上传的文件（压缩包）首先存储到 OSS 系统，并返回文件路径，路径与申报ID在数据库中关联。系统通过定时任务抢锁，查询申报表获取申报ID和文件地址，再拉取文件进行解压、解析，并按需修改文件名，添加申报ID，最后拆解成多个部分并重新打包，上传至对外服务器供第三方扫描审核。审核结果会存储到中间库，最终通过办结表反馈文件是否传输成功，确保文件与申报ID正确关联，并通过责任链模式进行拆解和分配文件处理任务。





 

# 代码讲解

> 后台详情页接口优化多线程优化

信息从很多地方加载   查询4张表   调用用户具体的信息    

 查询记录表 客服审核记录      查询申报信息    查询审核信息   查询办结表  调用用户中心 查询身份信息

串行的话 12345  组装数据  耗时大    

多线程的话   线程池threadpoolexecuter,submit  几个线程去做

concurrenthashmap    用key value 存储信息     返回到前端 让前端根据key来选择信息



countdownlatch来等子线程执行完  保证都执行完    

设置全局StringBuffer  赋值异常信息  看看有什么问题

**`countDown()`**：每次调用时，计数器减 1。通常在子线程完成任务时调用，表示该任务已完成。

**`await()`**：使调用该方法的线程等待，直到计数器减到零为止。如果计数器已经为零，`await()` 方法会立即返回。  当多个线程并行执行任务，需要等待所有线程都完成后，主线程才能继续执行。



串行查表变成并行查表

> redis优化多级分类（行业 类型  小分类）

数据库  1张分类表  1000种分类     parentid 对应什么类

1  list list list  递归查  这样的话很卡



Redis String     查key    组装完缓存进redis

缓存一致性问题  保证最终一致性

延迟双删  读写锁   异步





> 慢sql调优

运维群线上监控有慢mysql产生  直接跳到链路层  看到具体sql

拿到具体sql进行分析



用户登录会有token  调用用户中心去表里面查token  6位纯数字    varchar类型  查询没有带单引号    88万数据  30多秒

int和varchar的问题  没有按varchar类型的索引走 导致故障

数据量小的时候没问题   数据量大后就出问题了

如果查询条件未带双引号（即 `WHERE token = 123456` 而不是 `WHERE token = '123456'`），数据库可能会对 `VARCHAR` 类型的 `token` 进行隐式类型转换，从而无法走索引，导致全表扫描。





用户身份id+创建时间

查的时候不是最左匹配  导致联合索引失效



> 大表拆解

申报表  700到800条数据     单纯记录表 3000万条     

记录表分成11张表   record_0  record_1.................

假如申请单  id 是100     100取模11   结果是什么就去哪张表

 每张表存以下信息：id,关联申请单id, 创建时间 操作类型  客服id

查询： 申请单id

以前的表做数据清洗，开定时任务，查询历史申请单表，半年的，一百万申请单数据---》查旧记录表---->关联到新的记录表   

> 注解加AOP 分布式锁解决页面重复提交问题

防止用户因为网络问题 创建重复 申请单， 用入参+方法+身份证值（唯一信息）  做MD5  作为key放进去redis

用切点

在方法执行前，统一拦截所有需要防重复提交的方法。

通过注解 `@PreventRepeatSubmit` 标识需要拦截的接口。





**如果 Key 不存在**（说明是第一次提交），写入 Redis 并设置过期时间（如 10 秒）。

**如果 Key 已存在**（说明短时间内重复提交），直接拦截请求，返回错误信息。



**Redis 分布式锁** 通过 `SETNX` 机制控制请求，确保同一用户在短时间内只能提交一次。

**支持集群部署**：多个服务节点共享 Redis 状态，防止并发问题。

**高性能**：Redis `SETNX` 操作是 O(1) 级别，查询和加锁成本低。

**可自动过期**：Redis 自带过期机制，防止死锁。

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface PreventRepeatSubmit {
    long expireTime() default 5; // 默认5秒内禁止重复提交
}



@Aspect
@Component
public class RepeatSubmitAspect {
    
    @Autowired
    private StringRedisTemplate redisTemplate;
    
    @Around("@annotation(preventRepeatSubmit)") // 拦截带有 @PreventRepeatSubmit 的方法
    public Object doAround(ProceedingJoinPoint joinPoint, PreventRepeatSubmit preventRepeatSubmit) throws Throwable {
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
        
        // 生成 Redis Key（可以基于用户 ID + 请求路径）
        String userId = request.getSession().getAttribute("userId").toString(); // 假设用户已登录
        String key = "repeat_submit:" + userId + ":" + request.getRequestURI();

        // 尝试加锁 (防止重复提交)
        Boolean isSuccess = redisTemplate.opsForValue().setIfAbsent(key, "1", preventRepeatSubmit.expireTime(), TimeUnit.SECONDS);
        
        if (Boolean.FALSE.equals(isSuccess)) {
            // 如果 Redis 中已存在相同的 key，则认为是重复提交
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("请勿重复提交！");
        }
        
        // 执行原始方法
        try {
            return joinPoint.proceed();
        } finally {
            // 可选：处理完请求后，是否删除 Redis Key
            // redisTemplate.delete(key);
        }
    }
}




@RestController
@RequestMapping("/order")
public class OrderController {

    @PostMapping("/submit")
    @PreventRepeatSubmit(expireTime = 10) // 10秒内防止重复提交
    public ResponseEntity<String> submitOrder(@RequestBody OrderDTO order) {
        // 订单处理逻辑...
        return ResponseEntity.ok("订单提交成功");
    }
}


```

**面试可能会问  AOP  动态代理     日志框架  spring事务**  



>多线程库表交换

