# JVM

## 垃圾回收

JVM检测堆内存不足 新的对象无法分配空间  自动触发垃圾回收

可以手动









### 判断垃圾的方法

引用计数法和可达性分析算法



### 引用计数法

比较简单   计数器  有引用就加一  引用失效减1，  为0可以被回收

缺点：无法解决循环引用的问题（联想Spring的循环引用）

### 可达性分析算法

**从一组“根对象”开始**，沿着引用关系遍历整个对象图，标记所有可达的对象。

**不可达的对象** 会被认为是“垃圾”，可供回收。



> 根对象集合

1、虚拟机栈（栈帧中的本地变量表）中正在引用的对象

方法执行时，保存在栈上的局部变量（即方法内的变量）如果引用了对象，该对象是可达的。

2、本地方法栈中正在引用的对象：例如 `JNI` 代码中的 `native` 方法持有的对象。

3、静态属性引用的对象：例如类的 `static` 变量如果持有对象引用，该对象是可达的。

4、方法区常量引用的对象:比如 `String` 的常量池中的引用对象。





### 垃圾回收算法

#### 标记清除算法

标记-清除（Mark-and-Sweep）算法分为“（可达性分析算法）标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。

问题：

1. **效率问题**：标记和清除两个过程效率都不高。
2. **空间问题**：标记清除后会产生大量不连续的内存碎片。



#### 复制算法

为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收

缺点：

- **可用内存变小**：可用内存缩小为原来的一半。
- **不适合老年代**：如果存活对象数量比较大，复制性能会变得很差。

> 为什么不适合老年代

**老年代对象存活率高**（大部分对象长期存活），如果使用复制算法，每次 GC **需要复制大量对象**，导致 **复制成本太高，影响性能**。

但**老年代的空间本来就比较紧张**，不能浪费一半来做复制。

#### 标记整理算法

标记-整理（Mark-and-Compact）算法是根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。

由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景。





#### 分代收集算法

在新生代中，每次收集都会有大量对象死去，所以可以选择“复制”算法

老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。





### 垃圾回收器

主要是两个 CMS和G1



#### CMS收集器

已经在JAVA 14中被移除

**以获取最短回收停顿时间为目标**

CMS 收集器是一种 **“标记-清除”算法**实现的    **用在老年代  ，低延迟需求**

主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：

- **对 CPU 资源敏感；**
- **无法处理浮动垃圾；**
- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**



> 怎么并发的

 **初始标记（Initial Mark，STW）**

- **标记 GC Roots 直接可达的对象**（只标记第一层）。
- **暂停所有应用线程（STW），但时间很短**。

2️⃣ **并发标记（Concurrent Mark）**

- **从 GC Roots 继续遍历对象图**，标记所有可达对象。
- **与应用线程并发执行**，减少停顿时间。

3️⃣ **重新标记（Remark，STW）**

- **解决并发标记时的“浮动垃圾”**（应用线程可能在并发标记期间创建了新对象）。
- **暂停应用线程（STW），但优化后比初始标记时间稍长**。

4️⃣ **并发清除（Concurrent Sweep）**

- **回收未标记的对象**，释放内存。
- **与应用线程并发执行**，不会阻塞应用。



#### G1收集器

适合大内存  对内存碎片敏感

jdk9后默认

高并发 高吞吐量    用在老年代和新生代

G1 从整体来看是基于“**标记-整理”**算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。

G1 除了追求低停顿外，还能**建立可预测的停顿时间模型**

> 步骤？

**初始标记**： 短暂停顿（Stop-The-World，STW），标记从 GC Roots 可直接引用的对象，即标记所有直接可达的活跃对象

**并发标记**：与应用并发运行，标记所有可达对象。 这一阶段可能持续较长时间，取决于堆的大小和对象的数量。

**最终标记**： 短暂停顿（STW），处理并发标记阶段结束后残留的少量未处理的引用变更。

**筛选回收**：根据标记结果，选择回收价值高的区域，复制存活对象到新区域，回收旧区域内存。这一阶段包含一个或多个停顿（STW），具体取决于回收的复杂度。 



> region思想

**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)** 

根据设定的 **停顿时间目标**，G1 会动态调整从优先列表中选取的 Region 数量。如果**停顿时间越短**，就回收更少的 Region；如果**停顿时间允许更长**，就回收更多的 Region。

**例如**：如果停顿时间目标设为 **200ms**，G1 可能只回收几个最脏的 Region；如果目标是 **100ms**，它可能会减少要回收的 Region 数量，从而确保总的 GC 停顿时间不超过 100ms



#### G1和CMS区别在哪

> 第三阶段



CMS: 修正并发标记阶段（第二阶段）期间因用户线程运行导致的**对象引用变化**（漏标或错标）。通过**增量更新算法**（Incremental Update）重新扫描被修改的引用。

- 无法完全避免漏标，依赖后续的并发清理阶段处理。3



G1:基于**SATB（Snapshot-At-The-Beginning）**机制，处理并发标记期间的对象变化。

- 扫描所有在并发标记阶段新分配的对象（通过SATB队列记录）。
- 使用**并行线程**快速完成标记，减少停顿时间。



> 第四阶段

#### **CMS的“并发清除”（Concurrent Sweep）**

- **目的**：与用户线程**并发**清理未被标记的垃圾对象（标记-清除算法）。
- **工作内容**：
  - 不压缩内存，直接释放死亡对象占用的空间。
  - 会产生**内存碎片**，可能触发后续的Full GC（如Serial Old）。

#### **G1的“筛选回收”（Evacuation）**

- **目的**：**STW**阶段对选定的Region进行**复制整理**（Evacuation）。
- **工作内容**：
  - 根据回收价值（垃圾比例）选择Region，将存活对象复制到空闲Region（压缩内存）。
  - 更新RSet和引用关系。
- **特点**：
  - **无内存碎片**：通过复制算法整理内存。

它通过**复制算法（Evacuation） 在Region之间移动存活对象来实现内存整理，因此可以理解为 “基于复制的标记-整理”**

- 选择垃圾比例高的Region（Garbage-First原则），将其中的**存活对象复制（Evacuate）到空闲Region**。



#### CMS浮动垃圾问题？

是指在**并发标记和并发清理阶段**，由于用户线程继续运行而新产生的垃圾对象，这些对象无法在当前GC周期被回收，只能留到下一次GC处理。

CMS的设计目标是**减少STW（Stop-The-World）停顿时间**，所以它允许用户线程在标记和清理阶段并发执行。但这也带来了**副作用**

 重新标记（Remark）只能修正**部分**并发标记阶段漏标的垃圾，但无法处理**并发清理阶段**新产生的浮动垃圾。



> G1怎么解决的

SATB（Snapshot-At-The-Beginning）

1. **在并发标记开始时**，对整个堆做一个快照（Snapshot），之后所有新分配的对象**默认视为存活**。
2. **在最终标记（Remark）阶段**，只处理引用变化的部分，确保所有垃圾被正确识别。
3. **在筛选回收（Evacuation）阶段**，直接清理未被标记的对象，不会遗漏浮动垃圾。

比CMS少很多。







## 轻重GC与内存区

堆内存细分三个区域：新生区（伊甸园区）、老年区、永久区

新生区：伊甸园、幸存区0区、幸存区1区    动态概念    轻GC后没有被回收 进入幸存区    0和1区会交互

> 0区和1区怎么交互的

 Survivor 0区（S0）和 Survivor 1区（S1）\**是新生代（Young Generation）的重要组成部分，主要用于存放\**在Minor GC后仍然存活的对象**。它们的交互方式遵循**复制算法（Copying Algorithm）**

0和1左右弹跳 复制算法





对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。

假设GC次数为20

活下来后去养老区

Major GC  主要针对老年代进行回收，但不一定只回收老年代。   当老年代空间不足时，或者系统检测到年轻代对象晋升到老年代的速度过快，可能会触发Major GC。



养老区满了会触发重量级GC  (full GC) ，对整个堆内存（包括年轻代、老年代以及永久代/元空间）进行回收。







永久区（JDK8以后叫元空间）

这个区域常驻内存的。用来存放JDK自身携带的Class对象。Interface元数据，存储的是运行时的一些环境   这个区域不存在垃圾回收 ！  关闭虚拟机时就会释放





## 堆和栈

![Java 运行时数据区域（JDK1.8 ）](..\..\TyporaImage\java-runtime-data-areas-jdk1.8.png)



![Java 运行时数据区域（JDK1.8 ）](..\..\TyporaImage\java-runtime-data-areas-jdk1.8-17430677342952.png)

### 栈

Java 虚拟机栈（后文简称栈）也是线程私有的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。

每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。

![Java 虚拟机栈](..\..\TyporaImage\stack-area.png)
