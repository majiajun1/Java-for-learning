# 网络

## 基础知识

### OSI7层

##   ![OSI 七层模型](https://oss.javaguide.cn/github/javaguide/cs-basics/network/osi-7-model.png)

![osi七层模型2](https://oss.javaguide.cn/github/javaguide/osi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B2.png)

### **TCP/IP 四层模型** 

1. 应用层
2. 传输层
3. 网络层
4. 网络接口层

![TCP/IP 四层模型](https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-ip-4-model.png)







### 施工中





## NIO



### 内核空间和用户空间

内**核空间**：

- 内核空间是操作系统内核使用的内存区域。操作系统内核运行在特权模式下，它可以访问所有硬件资源和内存。内核空间有更高的权限，可以执行所有指令。
- 这个空间中的数据和代码可以访问整个计算机的硬件和其他系统资源（例如文件系统、网络、外设等）。
- 内核空间中一般存放操作系统内核、驱动程序、系统调用等关键代码。

**用户空间**：

- 用户空间是应用程序运行的内存区域。在这个区域运行的程序受到操作系统的保护，不能直接访问硬件资源或内核空间。
- 用户空间中的程序只能通过系统调用或 API 请求内核空间进行资源操作。任何访问内核空间的请求必须经过操作系统的调度和控制。
- 用户空间中的数据和代码与操作系统和硬件是隔离的，目的是提供应用程序安全的运行环境。

**最少最少都要两次DMA！ 一进一出**

### NIO三大件

- **Buffer**是数据的载体，用于存储数据。
- **Channel**是数据的传输通道，负责与Buffer交互。
- **Selector**是事件的管理者，监控多个Channel的状态，实现高效的多路复用。

![Buffer、Channel和Selector三者之间的关系](https://oss.javaguide.cn/github/javaguide/java/nio/channel-buffer-selector.png)

#### **缓冲区（Buffer）**：

- 在传统 I/O 中，数据是通过流（Stream）来传输的。而在 NIO 中，数据是通过缓冲区（Buffer）来存储和传输的。
- 缓冲区是一个内存块，它包含一个可以读取和写入数据的数组。NIO 的所有 I/O 操作都涉及到缓冲区。

~~~java
public abstract class Buffer {
    // Invariants: mark <= position <= limit <= capacity
    private int mark = -1;
    private int position = 0;
    private int limit;
    private int capacity;
}
~~~

1. 容量（`capacity`）：`Buffer`可以存储的最大数据量，`Buffer`创建时设置且不可改变；
2. 界限（`limit`）：`Buffer` 中可以读/写数据的边界。写模式下，`limit` 代表最多能写入的数据，一般等于 `capacity`（可以通过`limit(int newLimit)`方法设置）；读模式下，`limit` 等于 Buffer 中实际写入的数据大小。
3. 位置（`position`）：下一个可以被读写的数据的位置（索引）。从写操作模式到读操作模式切换的时候（flip），`position` 都会归零，这样就可以从头开始读写了。
4. 标记（`mark`）：`Buffer`允许将位置直接定位到该标记处，这是一个**可选属性；**

并且，上述变量满足如下的关系：**0 <= mark <= position <= limit <= capacity** 

![position 、limit 和 capacity 之前的关系](https://oss.javaguide.cn/github/javaguide/java/nio/JavaNIOBuffer.png)



![position 、limit 和 capacity 之前的关系](https://oss.javaguide.cn/github/javaguide/java/nio/NIOBufferClassAttributes.png)



![position 、limit 和 capacity 之前的关系](https://oss.javaguide.cn/github/javaguide/java/nio/NIOBufferClassAttributes.png)

`Buffer` 对象不能通过 `new` 调用构造方法创建对象 ，只能通过静态方法实例化 `Buffer`。

Buffer 最核心的两个方法：

1. `get` : 读取缓冲区的数据
2. `put` ：向缓冲区写入数据

这两个方法都是根据position来定位

除上述两个方法之外，其他的重要方法：

- `flip` ：将缓冲区从写模式切换到读模式，它会将 `limit` 的值设置为当前 `position` 的值，将 `position` 的值设置为 0。
- `clear`: 清空缓冲区，**将缓冲区从读模式切换到写模式**，并将 `position` 的值设置为 0，将 `limit` 的值设置为 `capacity` 的值。  注意 会换模式哦  不会真的清空 而是把limit和position重置

#### **通道（Channel）**：

- 通道类似于传统 I/O 中的流，但它可以双向传输数据（既可以读取数据，也可以写入数据）。全双工
- **FileChannel**、**SocketChannel** 和 **DatagramChannel** 等是常用的通道类型，它们分别用于文件 I/O、网络套接字 I/O 和数据报 I/O。.

 其中，最常用的是以下几种类型的通道：

- `FileChannel`：文件访问通道；
- `SocketChannel`、`ServerSocketChannel`：TCP 通信通道；
- `DatagramChannel`：UDP 通信通道；

Channel 最核心的两个方法：

1. `read` ：读取数据并写入到 Buffer 中。
2. `write` ：将 Buffer 中的数据写入到 Channel 中。

**选择器（Selector）**：

- NIO 提供了一个 **Selector** 类，它允许单个线程监听多个通道（Channel）的事件。通过 **Selector**，我们可以在单线程中实现多路复用，处理多个连接或文件 I/O。
- 这就使得 NIO 特别适合于高并发的网络应用，可以高效地处理大量的并发连接。

某假设个 Channel 上面有新的 TCP 连接接入、读和写事件，这个 Channel 就处于就绪状态，会被 Selector 轮询出来。Selector 会将相关的 Channel 加入到就绪集合中。通过 SelectionKey 可以获取就绪 Channel 的集合，然后对这些就绪的 Channel 进行相应的 I/O 操作

![Selector 选择器工作示意图](https://oss.javaguide.cn/github/javaguide/java/nio/selector-channel-selectionkey.png)

Selector 可以监听以下四种事件类型：

1. `SelectionKey.OP_ACCEPT`：表示通道接受连接的事件，这通常用于 `ServerSocketChannel`。
2. `SelectionKey.OP_CONNECT`：表示通道完成连接的事件，这通常用于 `SocketChannel`。
3. `SelectionKey.OP_READ`：表示通道准备好进行读取的事件，即有数据可读。
4. `SelectionKey.OP_WRITE`：表示通道准备好进行写入的事件，即可以写入数据。

`Selector`是抽象类，可以通过调用此类的 `open()` 静态方法来创建 Selector 实例。Selector 可以同时监控多个 `SelectableChannel` 的 `IO` 状况，是非阻塞 `IO` 的核心。

一个 Selector 实例有三个 `SelectionKey` 集合：

1. 所有的 `SelectionKey` 集合：代表了注册在该 Selector 上的 `Channel`，这个集合可以通过 `keys()` 方法返回。
2. 被选择的 `SelectionKey` 集合：代表了所有可通过 `select()` 方法获取的、需要进行 `IO` 处理的 Channel，这个集合可以通过 `selectedKeys()` 返回。
3. 被取消的 `SelectionKey` 集合：代表了所有被取消注册关系的 `Channel`，在下一次执行 `select()` 方法时，这些 `Channel` 对应的 `SelectionKey` 会被彻底删除，程序通常无须直接访问该集合，也没有暴露访问的方法。

简单案例：

~~~java
Set<SelectionKey> selectedKeys = selector.selectedKeys();
Iterator<SelectionKey> keyIterator = selectedKeys.iterator();
while (keyIterator.hasNext()) {
    SelectionKey key = keyIterator.next();
    if (key != null) {
        if (key.isAcceptable()) {
            // ServerSocketChannel 接收了一个新连接
        } else if (key.isConnectable()) {
            // 表示一个新连接建立
        } else if (key.isReadable()) {
            // Channel 有准备好的数据，可以读取
        } else if (key.isWritable()) {
            // Channel 有空闲的 Buffer，可以写入数据
        }
    }
    keyIterator.remove();
}
~~~

简单讲：新建channel和新建一个selector  然后将channel注册到selector （包括想要监听的事件）     用循环来轮值获取准备好的channel，把准备好的channel塞进set里面  用set的迭代器循环获取    每个channel对应的SelectionKey  然后根据key来做对应的操作   操作完当前的key后 删除迭代器这个key  

 番外：

`SelectionKey` 是与通道相关的事件标识符，每个注册到 `Selector` 上的通道都会对应一个 `SelectionKey`。`SelectionKey` 保存了有关通道、事件类型和其它元数据的信息。

`isAcceptable()` 和其他 `is` 方法（如 `isReadable()`, `isWritable()`）是基于 `SelectionKey` 中的 **就绪事件** 来判断的

`SelectionKey` 对象包含以下重要信息：

- `channel`：通道（如 `ServerSocketChannel` 或 `SocketChannel`）。
- `interestOps`：兴趣操作集（表示你希望监听的事件，如 `OP_ACCEPT`、`OP_READ`、`OP_WRITE`）。
- `readyOps`：已经就绪的操作集（表示当前可以进行的操作，如 `OP_ACCEPT` 表示连接请求可接受）。

`readyOps` 只能是 `interestOps` 的子集。即，`readyOps` 中的事件必须是你在 `interestOps` 中注册过的事件。

 是的，**如果 `interestOps` 与 `readyOps` 不符**，那就意味着当前没有准备好的事件可以处理。具体来说：

- **`interestOps`** 定义了你希望 `Selector` 监听哪些操作（如 `OP_READ`、`OP_WRITE`、`OP_ACCEPT` 等），但并不意味着这些操作总是会发生。
- **`readyOps`** 则表示当前 `Selector` 返回的、已准备好的事件。只有在 `readyOps` 中包含的操作才会被处理。

#### 处理逻辑：

1. **如果 `interestOps` 和 `readyOps` 不匹配：**
   - 如果你在 `interestOps` 中注册了某个事件（比如 `OP_READ`），但 `readyOps` 中没有该事件，说明该通道当前并不准备好进行该操作。
   - 这种情况下，`Selector` 不会返回该通道，或者即使返回了，也不会执行任何操作。你会跳过该通道，继续监听其他通道的事件。
2. **继续等待其他通道：**
   - `Selector.select()` 或 `selectNow()` 会一直等待，直到有通道的事件准备好。这时，它会返回包含准备好的事件的 `SelectionKey` 集合，你可以通过 `key.isReadable()`、`key.isWritable()` 等方法检查具体的操作。
   - 如果当前没有通道准备好某个事件，`Selector` 会返回 `readyOps` 为空的情况，或者只包含部分你关注的事件。此时，程序会继续等待直到有其他事件可处理。

**非阻塞 I/O**：

- 传统 I/O 通常是阻塞式的，即一个线程读取数据时，如果没有数据可读，它就会被阻塞，直到有数据到达。
- NIO 通过非阻塞 I/O（non-blocking I/O）来避免这种阻塞情况。一个线程可以检查通道是否有数据可用，如果没有数据，它可以继续执行其他任务，而不是被阻塞在 I/O 操作上。



### 零拷贝

NIO做到了零拷贝

传统的 I/O 操作中，数据从硬盘、网络等输入输出设备传输到内存时，通常需要经历多个步骤：

1. **从磁盘读取数据到内核缓冲区**。
2. **从内核缓冲区复制到用户空间缓冲区**（如果是网络 I/O，则是通过套接字进行数据传输）。
3. **从用户空间缓冲区写回到网络或磁盘**。

这些步骤都涉及到多次内存拷贝操作，造成了不必要的性能损失。尤其是当数据量很大时，这些内存拷贝会显著降低系统性能

**零拷贝**（Zero-Copy）是一种优化技术，旨在减少数据从一个地方复制到另一个地方时的内存拷贝操作。**其核心思想是尽可能避免在数据传输过程中将数据从内核空间复制到用户空间，再从用户空间复制回内核空间**，从而减少 CPU 和内存的开销。

数据可以直接从 **内核空间** 传输到 **内核空间**（例如从磁盘到网络，或者从磁盘到内存），或者从 **内核空间** 传输到 **用户空间**，而无需通过中间的内存复制。

 **NIO** 引入了 **通道（Channel）** 和 **缓冲区（Buffer）** 的概念，其中 **FileChannel** 提供了一种 **零拷贝** 的方式来减少不必要的数据复制。

可以在文件和网络数据传输中直接将数据从一个通道传输到另一个通道

NIO 中的 `FileChannel` 类提供了两种非常重要的方法，能够实现零拷贝：

1. **transferTo()**
2. **transferFrom()**

这两个方法可以直接在操作系统内核中进行数据传输，避免了将数据从内核缓冲区拷贝到用户缓冲区的过程。因此，减少了数据传输过程中的额外内存复制操作，从而实现了零拷贝。

零拷贝的常见实现技术有： `mmap+write`、`sendfile`和 `sendfile + DMA gather copy` 。





## 服务限流

### 固定窗口

其实就是时间窗口，其原理是将时间划分为固定大小的窗口，在每个窗口内限制请求的数量或速率，即固定窗口计数器算法规定了系统单位时间处理的请求数量。

超过就归0

缺点：

- 限流不够平滑。例如，我们限制某个接口每分钟只能访问 30 次，假设前 30 秒就有 30 个请求到达的话，那后续 30 秒将无法处理请求，这是不可取的，用户体验极差！
- 无法保证限流速率，因而无法应对突然激增的流量。例如，我们限制某个接口 1 分钟只能访问 1000 次，该接口的 QPS 为 500，前 55s 这个接口 1 个请求没有接收，后 1s 突然接收了 1000 个请求。然后，在当前场景下，这 1000 个请求在 1s 内是没办法被处理的，系统直接就被瞬时的大量请求给击垮了。 

### 滑动窗口

**滑动窗口计数器算法** 算的上是固定窗口计数器算法的升级版，限流的颗粒度更小。

滑动窗口计数器算法相比于固定窗口计数器算法的优化在于：**它把时间以一定比例分片** 。

例如我们的接口限流每分钟处理 60 个请求，我们可以把 1 分钟分为 60 个窗口。每隔 1 秒移动一次，每个窗口一秒只能处理不大于 `60(请求数)/60（窗口数）` 的请求， 如果当前窗口的请求计数总和超过了限制的数量的话就不再处理其他请求。

很显然， **当滑动窗口的格子划分的越多，滑动窗口的滚动就越平滑，限流的统计就会越精确。**

缺点：

- 与固定窗口计数器算法类似，滑动窗口计数器算法依然存在限流不够平滑的问题。
- 相比较于固定窗口计数器算法，滑动窗口计数器算法实现和理解起来更复杂一些。

### 漏桶算法

我们可以把发请求的动作比作成注水到桶中，我们处理请求的过程可以比喻为漏桶漏水。我们往桶中以任意速率流入水，以一定速率流出水。当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。

如果想要实现这个算法的话也很简单，准备一个队列用来保存请求，然后我们定期从队列中拿请求来执行就好了（和消息队列削峰/限流的思想是一样的）。

缺点：

- 无法应对突然激增的流量，因为只能以固定的速率处理请求，对系统资源利用不够友好。
- 桶流入水（发请求）的速率如果一直大于桶流出水（处理请求）的速率的话，那么桶会一直是满的，一部分新的请求会被丢弃，导致服务质量下降。

实际业务场景中，基本不会使用漏桶算法。

### 令牌桶

不过现在桶里装的是令牌了，请求在被处理之前需要拿到一个令牌，请求处理完毕之后将这个令牌丢弃（删除）。我们根据限流大小，按照一定的速率往桶里添加令牌。如果桶装满了，就不能继续往里面继续添加令牌了。

缺点：

- 如果令牌产生速率和桶的容量设置不合理，可能会出现问题比如大量的请求被丢弃、系统过载。
- 相比于其他限流算法，实现和理解起来更复杂一些。



### 其他

针对 IP 进行限流是目前比较常用的一个方案。不过，实际应用中需要注意用户真实 IP 地址的正确获取。常用的真实 IP 获取方法有 X-Forwarded-For 和 TCP Options 字段承载真实源 IP 信息。虽然 X-Forwarded-For 字段可能会被伪造，但因为其实现简单方便，很多项目还是直接用的这种方法。

除了我上面介绍到的限流对象之外，还有一些其他较为复杂的限流对象策略，比如阿里的 Sentinel 还支持 [基于调用关系的限流](https://github.com/alibaba/Sentinel/wiki/流量控制#基于调用关系的流量控制)（包括基于调用方限流、基于调用链入口限流、关联流量限流等）以及更细维度的 [热点参数限流](https://github.com/alibaba/Sentinel/wiki/热点参数限流)（实时的统计热点参数并针对热点参数的资源调用进行流量控制）

单机限流针对的是单体架构应用。

单机限流可以直接使用 Google Guava 自带的限流工具类 `RateLimiter` 。 `RateLimiter` 基于令牌桶算法，可以应对突发流量。

> Guava 地址：https://github.com/google/guava

除了最基本的令牌桶算法(平滑突发限流)实现之外，Guava 的`RateLimiter`还提供了 **平滑预热限流** 的算法实现。

平滑突发限流就是按照指定的速率放令牌到桶里，而平滑预热限流会有一段预热时间，预热时间之内，速率会逐渐提升到配置的速率。

~~~java
// 1s 放 5 个令牌到桶里也就是 0.2s 放 1个令牌到桶里
        // 预热时间为3s,也就说刚开始的 3s 内发牌速率会逐渐提升到 0.2s 放 1 个令牌到桶里
        RateLimiter rateLimiter = RateLimiter.create(5, 3, TimeUnit.SECONDS);
 
~~~

Resilience4j 是一个轻量级的容错组件，其灵感来自于 Hystrix。自[Netflix 宣布不再积极开发 Hystrix](https://github.com/Netflix/Hystrix/commit/a7df971cbaddd8c5e976b3cc5f14013fe6ad00e6) 之后，Spring 官方和 Netflix 都更推荐使用 Resilience4j 来做限流熔断。

> Resilience4j 地址: https://github.com/resilience4j/resilience4j



分布式限流常见的方案：

- **借助中间件限流**：可以借助 Sentinel 或者使用 Redis 来自己实现对应的限流逻辑。
- **网关层限流**：比较常用的一种方案，直接在网关层把限流给安排上了。不过，通常网关层限流通常也需要借助到中间件/框架。就比如 Spring Cloud Gateway 的分布式限流实现`RedisRateLimiter`就是基于 Redis+Lua 来实现的，再比如 Spring Cloud Gateway 还可以整合 Sentinel 来做限流。 



**为什么建议 Redis+Lua 的方式？** 主要有两点原因：

- **减少了网络开销**：我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。
- **原子性**：一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。



 Redisson 中的 `RRateLimiter` 来实现分布式限流，其底层实现就是基于 Lua 代码+令牌桶算法。

Redisson 是一个开源的 Java 语言 Redis 客户端，提供了很多开箱即用的功能，比如 Java 中常用的数据结构实现、分布式锁、延迟队列等等。并且，Redisson 还支持 Redis 单机、Redis Sentinel、Redis Cluster 等多种部署架构。

`RRateLimiter` 的使用方式非常简单。我们首先需要获取一个`RRateLimiter`对象，直接通过 Redisson 客户端获取即可。然后，设置限流规则就好。

~~~java
// 创建一个 Redisson 客户端实例
RedissonClient redissonClient = Redisson.create();
// 获取一个名为 "javaguide.limiter" 的限流器对象
RRateLimiter rateLimiter = redissonClient.getRateLimiter("javaguide.limiter");
// 尝试设置限流器的速率为每小时 100 次
// RateType 有两种，OVERALL是全局限流,ER_CLIENT是单Client限流（可以认为就是单机限流）
rateLimiter.trySetRate(RateType.OVERALL, 100, 1, RateIntervalUnit.HOURS);

接下来我们调用acquire()方法或tryAcquire()方法即可获取许可。
    
    // 获取一个许可，如果超过限流器的速率则会等待
// acquire()是同步方法，对应的异步方法：acquireAsync()
rateLimiter.acquire(1);
// 尝试在 5 秒内获取一个许可，如果成功则返回 true，否则返回 false
// tryAcquire()是同步方法，对应的异步方法：tryAcquireAsync()
boolean res = rateLimiter.tryAcquire(1, 5, TimeUnit.SECONDS);
~~~



 

