# 操作系统

## 用户态和内核态

> 区别？

内核态 CPU可以执行所有的指令和访问所有的硬件资源  权限更高   用于操作系统内核的运行

用户态  CPU权限比较低  主要用于运行用户程序



避免恶意程序直接调用内核函数  有利于系统的维护模块化   故障分离



## 进程

### 底层





> 进程和线程的区别？

线程共享进程的资源 不会为线程分配内存    但是线程自己资源不共享 （ThreadLocal联想）

进程是资源分配的基本单位  线程是任务调度和执行的基本单位

故障隔离     进程的程序和上下文切换开销大，但是线程切换开销小（会有竞争）



进程也有隔离性和独立性 对其他进程不会有影响



> 进程分配的资源是？

虚拟内存  文件句柄、信号量

文件句柄指文件的标识  每个文件都有唯一标识



> 为什么要设计线程

串行化导致速度很慢

如果不是前后依赖的数据的话  可以并发执行     最后再组装数据   

但是多进程会有通信问题，维护进程创建和销毁开销很大

需要一种可以共享资源和并发运行的实体

> 多线程的劣势和优势

劣势的话 有线程安全问题  需要锁机制

优势是 执行速度更快 利用多核处理器的优势

> 多线程的数量？

销毁始终要开销，而且锁要更复杂了  可能会死锁



> 进程切换和线程切换区别？

进程切换开销更大   进程涉及到地址空间 全局变量  文件描述符

线程只涉及到线程堆栈  寄存器  程序计数器等





线程堆栈： **递归调用** 过程中，每次递归都会创建新的栈帧

> 线程切换的过程 (实现并发执行)

操作系统保存上下文信息---->执行权转移到调度器，选择下一个线程----->从保存的上下文信息中恢复执行---->执行权切换到新线程

上下文信息保存在TCB（每个线程一个）



> 进程状态

创建 

就绪和阻塞 运行 三态的变化

结束



阻塞只能由运行态转变来   然后阻塞等到事件完成后去到就绪态

> 进程的上下文

进程的切换---》上下文切换  就是时间片分配（并发）的问题嘛  

上下文切换问题主要的key：保存运行状态   就是说运行的位置 （指令位置--->PC计数器和寄存器）

进程上下文切换：虚拟内存 栈 全局变量  内核堆栈  寄存器     保存后  然后调度下一个进程 让这个进程读取自己的上下文信息





### 进程、线程通讯

> 管道  都是单向的

匿名管道：无格式的流，大小受限 单向通信，只能用于父子关系的进程之间通信

命名管道：关系无限制， 严格 **先进先出**

> 消息队列

消息的链表，**有特定格式**，FIFO  也**可以随机查询**  ，与管道不同的是消息队列放在内核中，内核重启（或显式删除）才会删除

> 信号量

计数器   锁机制

>信号

和信号量不同，用于通知接收进程某个事件已经发生

**进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号**

> 共享内存

分配共享空间 让大家访问 最快

> Socket

TCP  UDP  本地进程间通信



> 共享内存怎么实现的？

**拿出一块虚拟地址空间来，映射到相同的物理内存中**

> 线程间的通讯？

 互斥锁   条件变量 Condition    自旋锁 CAS     信号量    读写锁

这几个太常见了

自旋锁 不停地查锁的状态

### 线程调度

> 先来先服务

先来先服务 （FIFO）

先来后到

最先的运行完才能后面

> 最短作业优先调度算法

优先运行时间短的

对长作业不利  非抢占式

>最短剩余时间优先

抢占式  

运行时间比现在运行的进程剩余时间短 就运行这个

> 高响应比优先调度算法

权衡了短作业和长作业

![img](D:\Document\JAVA\TyporaImage\1720958126833-a4591dd3-4c82-4c06-be20-cb8682cd5b5a.png)

等待时间相同，要求服务时间越长 则优先权越高  利于短作业

要求服务时间一样，等待时间越长，兼顾长作业

（但总体还是利于短作业）

>时间片轮转调度算法

该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；

到时就切

通常时间片设为 `20ms~50ms` 通常是一个比较合理的折中值。

轮着来 没啥

> 最高优先级调度算法

**从就绪队列中选择最高优先级的进程进行运行**

 静态和动态优先级 (动态的话可以自己设置)

非抢占式和抢占式的(当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。)

>多级反馈队列调度算法

![img](D:\Document\JAVA\TyporaImage\1720958157105-0947c14a-f422-464a-9294-7cf5ef8a23bd.png)

 每个**队列优先级从高到低**，同时**优先级越高时间片越短**；

新进程先进第一队列 然后没执行完就往下走

高的队列空了 才会去执行低的队列的进程 

**如果有新的加入（高的队列）**则停下移入到原队列末尾  让优先级高的先运行

如果没新的加入  在这个队列还是没执行完 则继续往下走



## 锁 （结合java锁来看吧）

> 自旋锁

CAS函数把两道步骤合成一道原子命令

看锁的状态，加锁

用while来自旋

需要注意,在单核 CPU 上,需要抢占式的调度器(即不断通过时钟中断一个线程,运行其他程序），否则while循环会卡死

> 死锁条件

互斥条件

持有并等待条件

不可剥夺条件

环路等待条件



> 如何避免死锁 与银行家算法

**使用资源有序分配法，来破环环路等待条件**。





银行家算法：本质上是一种DFS  做算术罢了没啥





> 乐观锁和悲观锁

悲观锁 ：抢占式  先来者抢占锁 占有资源  互斥

乐观锁：适用于读多写少的场景  读数据时不会加锁  更新时检查版本 匹配则更新  否则认为发生冲突。

冲突的话看处理策略咯   可以抛异常  也可以读最新的来取





## 内存管理(可以结合JVM)

### 虚拟内存和页表

每个进程有自己的虚拟内存，使进程的运行内存超过物理内存大小（放磁盘上了）

每个进程的页表私有  互不干涉   每个进程页表只有一个？

标记是否存在和权限  比直接访问物理内存更安全

**内存管理单元** （*MMU*）就做将虚拟内存地址转换成物理地址的工作。

缺页就重新找  更新页表

![img](D:\Document\JAVA\TyporaImage\1720434118095-d8674984-2006-4e28-8e41-bb487f8f559c.png)

 

> 段表

应用程序的虚拟地址空间被分为大小不等的段，段是有实际意义的，每个段定义了一组逻辑信息，例如有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等

> 区别?

页大小固定   而段不固定



分段会有外部内存碎片    而这些段可能在物理内存中不连续地分布。随着段的分配和释放，内存中可能会有一些空闲区域

分页有内部内存碎片    每一页的大小是固定的，当一个段的数据小于一页时，剩余的内存就会浪费掉



段表记录每个段的基地址和段的大小。  页表记录虚拟页号与物理页号的映射关系。



> 段页机制

段页机制将程序的内存划分为多个**段**，每个段内部再被划分成若干个**页**。这一机制将分段和分页的优点结合在一起

**段号（Segment Number）**：用来标识程序中的哪个段（如代码段、数据段等）。

**页号（Page Number）**：用来标识段内的哪一页。  （相对于基地址的）

**页内偏移（Offset）**：标识页内的具体位置，表示数据在页内的位置。

> TLB和多级页表

TLB 存储了最近访问过的虚拟地址到物理地址的映射（即页表项）。当程序访问内存时，TLB 会首先检查该地址的映射是否存在，如果存在（称为TLB命中），则直接获取物理地址。如果映射不在TLB中（称为TLB未命中），系统会去查找页表，并将新的映射加载到TLB中。

### 内存其他



> 内存布局

