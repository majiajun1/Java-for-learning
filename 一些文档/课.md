# 业务讲解 笔记

申请信息 讯飞初审 -->没问题  传给第三方接口  --->再传给客户端

和第三方对接口 

 

第三方机构 数据保密性很强

用户申报信息-->审核基础信息，放在公司内部数据库查信息-->通过后，申报表 放在对外数据库--->第三方定时从外部数据库拉数据到内部服务器--->审核-->审核结果（申报表）放在第三方对外数据库---->we 拉数据    保存我们对内数据库---->用户看到申报流程





数据越拉越多    Elasticsearch  优化负载                  

申报信息有筛选条件  还有图片  十几个   数据量大访问会大    一千万条数据 十几个筛选条件      



通过定时任务 迁徙到ES上面去      ES只存有没有提交图片的状态（只存有无填写的状态） 只关联申报信息的ID      详情的按钮  点了详情再走组件索引   没走索引查了几十秒



redis 广告接入  收集用户推广 插入广告   redis oom问题     定时拉取广告ID（每天的） key 加了今天的日期  没有设置过期时间  广告ID是一个json   导致越存越多 OOM  

通过日期来匹配广告ID        通过今天的日期来匹配到广告ID      然后还要去平台根据ID拉取请求一次

做成异步   线程池   future对象 get 方法（有超时参数）  广告 则不插入



申报表的ID来查   

办结表有那条ID  那就是办结了  无状态

库表交换 不愿意开放接口 保证安全  



定时任务拉数据 往两边扩展一点  有重叠数据 不会漏      不重复就可以插入进去         防止定时任务漏东西  回滚 再拉



sql调优





报表 申报表 申报失败表 审核中的表  可以多线程的查      



年龄段分组  所处行业的分组    联合索引 新建B+树来组合查询    最左匹配原则  按照组合查询的索引的顺序 最左匹配   例如(A,B,C)的联合索引   那sql语句只能 A AB  ABC     不能BA AC  BC 和单列  这样用不到组合查询   跳过中间条件来查的话 只会用到部分的组合索引 然后再单列索引（无法加速）



MQ消息提示 通知客服审核 功能         前端页面弹东西                

  MQ把数据同步到ES ?

   用户创建申报信息之后    到数据库  然后返回主键ID   MQ异步发主键ID      用户拿到主键ID     去表里面查一次  保证表里面有数据  再把数据迁移到ES（存状态） 异步



> 文件交换平台

 推文件 推到第三方文件服务器   第三方去扫  

用户提交文件 上传到系统 返回文件的路径    路径存在我们的数据库  关联申报ID     再通过库表交换的形式把文件读出来



文件是一个压缩包形式  先到OSS系统  返回地址   解析文件成几份  因为需要的文件不一样  **责任链模式**   放在公开服务器的某个目录下面      拆出来后  再打包压缩包 拿过去审核   把结果放在中间库  我们拉结果   那办结表会有几条数据（就是反应哪个文件传错了 全部传对那就没事）     （理解成不同的人负责审的文件不一样）  （定时任务）



刚开始是大的压缩包  后面就三个   第三方扫文件  都关联申报ID     文件名上带申报ID就好了



定时任务抢锁 往前推半个小时  查申报表       获取申报ID 和文件地址     再去扫数据库获取文件   （解压 解析  要改名 加申报ID  文件的格式）    分别打包放到对外服务器上面  



**总结版：**该系统实现了一个文件上传与审核的流程，用户上传的文件（压缩包）首先存储到 OSS 系统，并返回文件路径，路径与申报ID在数据库中关联。系统通过定时任务抢锁，查询申报表获取申报ID和文件地址，再拉取文件进行解压、解析，并按需修改文件名，添加申报ID，最后拆解成多个部分并重新打包，上传至对外服务器供第三方扫描审核。审核结果会存储到中间库，最终通过办结表反馈文件是否传输成功，确保文件与申报ID正确关联，并通过责任链模式进行拆解和分配文件处理任务。





 

# 代码讲解

> 后台详情页接口优化多线程优化

信息从很多地方加载   查询4张表   调用用户具体的信息    

 查询记录表 客服审核记录      查询申报信息    查询审核信息   查询办结表  调用用户中心 查询身份信息

串行的话 12345  组装数据  耗时大    

多线程的话   线程池threadpoolexecuter,submit  几个线程去做

concurrenthashmap    用key value 存储信息     返回到前端 让前端根据key来选择信息



countdownlatch来等子线程执行完  保证都执行完    

设置全局StringBuffer  赋值异常信息  看看有什么问题

**`countDown()`**：每次调用时，计数器减 1。通常在子线程完成任务时调用，表示该任务已完成。

**`await()`**：使调用该方法的线程等待，直到计数器减到零为止。如果计数器已经为零，`await()` 方法会立即返回。  当多个线程并行执行任务，需要等待所有线程都完成后，主线程才能继续执行。



串行查表变成并行查表

> redis优化多级分类（行业 类型  小分类）

数据库  1张分类表  1000种分类     parentid 对应什么类

1  list list list  递归查  这样的话很卡



Redis String     查key    组装完缓存进redis

缓存一致性问题  保证最终一致性

延迟双删  读写锁   异步





> 慢sql调优

运维群线上监控有慢mysql产生  直接跳到链路层  看到具体sql

拿到具体sql进行分析



用户登录会有token  调用用户中心去表里面查token  6位纯数字    varchar类型  查询没有带单引号    88万数据  30多秒

int和varchar的问题  没有按varchar类型的索引走 导致故障

数据量小的时候没问题   数据量大后就出问题了

如果查询条件未带双引号（即 `WHERE token = 123456` 而不是 `WHERE token = '123456'`），数据库可能会对 `VARCHAR` 类型的 `token` 进行隐式类型转换，从而无法走索引，导致全表扫描。





用户身份id+创建时间

查的时候不是最左匹配  导致联合索引失效



> 大表拆解

申报表  700到800条数据     单纯记录表 3000万条     

记录表分成11张表   record_0  record_1.................

假如申请单  id 是100     100取模11   结果是什么就去哪张表

 每张表存以下信息：id,关联申请单id, 创建时间 操作类型  客服id

查询： 申请单id

以前的表做数据清洗，开定时任务，查询历史申请单表，半年的，一百万申请单数据---》查旧记录表---->关联到新的记录表   

> 注解加AOP 分布式锁解决页面重复提交问题

防止用户因为网络问题 创建重复 申请单， 用入参+方法+身份证值（唯一信息）  做MD5  作为key放进去redis

用切点

在方法执行前，统一拦截所有需要防重复提交的方法。

通过注解 `@PreventRepeatSubmit` 标识需要拦截的接口。





**如果 Key 不存在**（说明是第一次提交），写入 Redis 并设置过期时间（如 10 秒）。

**如果 Key 已存在**（说明短时间内重复提交），直接拦截请求，返回错误信息。



**Redis 分布式锁** 通过 `SETNX` 机制控制请求，确保同一用户在短时间内只能提交一次。

**支持集群部署**：多个服务节点共享 Redis 状态，防止并发问题。

**高性能**：Redis `SETNX` 操作是 O(1) 级别，查询和加锁成本低。

**可自动过期**：Redis 自带过期机制，防止死锁。

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface PreventRepeatSubmit {
    long expireTime() default 5; // 默认5秒内禁止重复提交
}



@Aspect
@Component
public class RepeatSubmitAspect {
    
    @Autowired
    private StringRedisTemplate redisTemplate;
    
    @Around("@annotation(preventRepeatSubmit)") // 拦截带有 @PreventRepeatSubmit 的方法
    public Object doAround(ProceedingJoinPoint joinPoint, PreventRepeatSubmit preventRepeatSubmit) throws Throwable {
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
        
        // 生成 Redis Key（可以基于用户 ID + 请求路径）
        String userId = request.getSession().getAttribute("userId").toString(); // 假设用户已登录
        String key = "repeat_submit:" + userId + ":" + request.getRequestURI();

        // 尝试加锁 (防止重复提交)
        Boolean isSuccess = redisTemplate.opsForValue().setIfAbsent(key, "1", preventRepeatSubmit.expireTime(), TimeUnit.SECONDS);
        
        if (Boolean.FALSE.equals(isSuccess)) {
            // 如果 Redis 中已存在相同的 key，则认为是重复提交
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("请勿重复提交！");
        }
        
        // 执行原始方法
        try {
            return joinPoint.proceed();
        } finally {
            // 可选：处理完请求后，是否删除 Redis Key
            // redisTemplate.delete(key);
        }
    }
}




@RestController
@RequestMapping("/order")
public class OrderController {

    @PostMapping("/submit")
    @PreventRepeatSubmit(expireTime = 10) // 10秒内防止重复提交
    public ResponseEntity<String> submitOrder(@RequestBody OrderDTO order) {
        // 订单处理逻辑...
        return ResponseEntity.ok("订单提交成功");
    }
}


```

**面试可能会问  AOP  动态代理     日志框架  spring事务**  



> redis

String  存 token 秘钥  

hash  匹配来源  再根据当前日期 来匹配当前广告信息(json)  后面要做操作 zset

广告  origin  ad_time   {40,广告id，广告展示位置，广告运营时间，广告名称，合作方，广告的操作数  分值}

每个广告都有自己的分值

set  库表交换，  推到对外开放的表并把数据id存redis,  set集合(匹配 在不在set集合)  防止重复扫描 

Zset   广告的次序     把json分成zset的格式       夜晚取分值小的  早上取分值多的



> ES

什么是倒排索引，和正排的区别   es的索引结果怎么建立的   

**倒排索引**：从**单词到文档的映射**，适用于**全文检索**，查询速度快。

**正排索引**：从**文档到单词的映射**，适用于**存储数据**，但查询速度慢。

**Elasticsearch 采用倒排索引**：

- **分词**：先拆分文本
- **索引**：建立倒排索引，加快查询
- **查询**：搜索时直接查倒排索引，提高性能





为什么引入ES

网页页面  

初始审核只显示基础信息  因为速度要求   详细审核    点击后有详情    申请单的十几个筛选条件 不可能全部马上显示



申请单图片，存图片表 关联申请单id     ES存有无举证啥的  存一些状态信息  评分？啥的  就是暂时不重要不是详情的东西

页面上十来个搜索框   ES只保存状态

带上mq  查

引入ES   组件索引   申请单id   申请单工单id  关键词   用户年龄，创建时间  有无举证   申请单一级分类  二级分类  三级分类.....



拿到申请单  点击详情后  再走数据库

 **初审页面** 只显示 **基础信息**，需要**快速返回结果**，不能等数据库慢查询。







###  **结合 MQ（消息队列）确保数据实时同步**

- 申请单的状态、审核信息、分类等信息可能会**实时变更**。
- **MySQL 负责存储数据**，但索引数据需要**同步到 ES**，否则搜索结果可能会延迟。
- **引入 MQ（消息队列）**，保证数据更新后，**实时同步到 ES**，让搜索结果始终**保持最新状态**。





## MQ

**RocketMQ**

**阿里巴巴开源**，适用于**金融、电商业务**





MQ和ES  要看看





# 答疑

 申报表 

审核表

办结表





> 水平分表

一条申请单---->多条记录             客服操作的数据  都有申请id

根据申请id来分表， 分记录表



>过期时间

一开始存redis不需要过期时间 后台配置开始时间结束时间      取数据的时候在里面时间就展示数据    不在就返回空  redis删缓存



> 有个白名单

调用白名单





ES总数据量 一亿以上         低峰期：几个 n   高峰期：一百多个      （高考查询成绩）

 

> 为什么要用ES

思想类似于懒加载

先把重要（简单）信息存在ES里面   比如有没有上传图片  申请id     申请单状态   申请单类型  创建时间   VIP用户。。。。

   点详情  走组件索引去数据库 取具体信息    防止数据库卡死（数据库索引有限制）

 

> ES改造

新的数据去向  用户提交申报信息  数据库存一份   ES也要存一份      MQ来做

 历史数据的话  定时任务往ES里面调度  （不是MQ）

 

> MQ

异步放到ES里面

用户申报信息  插入数据库后  返回主键ID   发消息主键ID        MQ消费者接收信息  数据库再查一次  组装数据   然后执行插入ES





很多用户申办办件   MQ 消费者慢慢消费即可  异步操作





> ES一致性问题

  插入失败怎么办？

For循环重试三次  三次失败就告警



> ES和数据库有什么区别

ES场景  索引怎么设计的？

ES分词





> MQ延迟消息怎么做  为什么要延迟消息

word文档的**审批超时提醒功能等？**





> 事务

第三方接口





> 集合在项目的用处

查多条数据库用LIST

多线程库表分表   查过来放到集合里面去  再进行内部的插入

历史数据



Map    对应的工厂模式设计

MAP  转成JSON



> 跟第三方的接口怎么对接

交流一下接口

 IP和接口名

  接口请求的验证信息    入参   

get post 

状态码
返回类型

请求方式



接口地址

鉴权方式

你在与第三方交流接口信息时，主要沟通： 1. **接口地址**（Base URL、环境） 2. **鉴权方式**（Token、OAuth、JWT） 3. **请求方式和参数**（Headers、Body、Query、Path） 4. **响应格式和状态码** 5. **频率限制、超时策略** 6. **异常处理** 7. **回调机制**





ES主要存申报中的信息



# 话术答疑



都写在话术文件了

还有问题答疑没看
