# 注解和反射

注解不是必须的  不影响方法本身

相当于添加辅助信息

@Override  只适用于修辞方法  打算重写超类的另一个方法声明

@Deprecated 修辞方法属性类，表示不鼓励使用    

@SuppressWarnings   抑制编译时的警告信息

```java
@SuppressWarnings("all")
@SuppressWarnings("unchecked")
@SuppressWarnings(value={"unchecked","deprecation"})
```



元注解  注解其他的注解   java定义了四个meta-annotation

@Target   描述注解的使用范围

@Retention  表示需要在什么级别保存该注释信息  描述注解的生命周期

只有这三个 一般在runtime

(SOURCE <CLASS<RUNTIME)

 @Documented    说明该注解将被包含在javadoc中

@Inherited   Inherited 子类可以继承父类的注解

```
public @interface Target {
 
    ElementType[] value();
}
public enum ElementType {
    /** Class, interface (including annotation type), or enum declaration */
    TYPE,

    /** Field declaration (includes enum constants) */
    FIELD,

    /** Method declaration */
    METHOD,

    /** Formal parameter declaration */
    PARAMETER,

    /** Constructor declaration */
    CONSTRUCTOR,

    /** Local variable declaration */
    LOCAL_VARIABLE,

    /** Annotation type declaration */
    ANNOTATION_TYPE,

    /** Package declaration */
    PACKAGE,

    /**
     * Type parameter declaration
     *
     * @since 1.8
     */
    TYPE_PARAMETER,

    /**
     * Use of a type
     *
     * @since 1.8
     */
    TYPE_USE
}
public enum RetentionPolicy {
    /**
     * Annotations are to be discarded by the compiler.
     */
    SOURCE,

    /**
     * Annotations are to be recorded in the class file by the compiler
     * but need not be retained by the VM at run time.  This is the default
     * behavior.
     */
    CLASS,

    /**
     * Annotations are to be recorded in the class file by the compiler and
     * retained by the VM at run time, so they may be read reflectively.
     *
     * @see java.lang.reflect.AnnotatedElement
     */
    RUNTIME
}

```



自定义注解  @interface 



## 反射

java视为动态语言的关键

直接操作任意对象的内部属性及方法

```
Class  aClass = Class.forName("Zhujie.user");
```

获取类名字   

```
user user1 = new user();
System.out.println(user1.getClass().hashCode()); //这个也行 因为所有类都继承object    object里面有getclass

//方式三：通过类名.class获得
        Class c3=Student.class;
        System.out.println(c3.hashCode());
        //方式四：基本内置类型的包装类 都有一个Tpye属性
        Class  type = Integer.TYPE;
        System.out.println(type);
```

![image-20241213214039181](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241213214039181.png)

## 类加载内存分析

类的加载-》类的连接-》类的初始化



![image-20241214154101382](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241214154101382.png)