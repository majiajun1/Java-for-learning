# 注解和反射

注解不是必须的  不影响方法本身

相当于添加辅助信息

@Override  只适用于修辞方法  打算重写超类的另一个方法声明

@Deprecated 修辞方法属性类，表示不鼓励使用    

@SuppressWarnings   抑制编译时的警告信息

```java
@SuppressWarnings("all")
@SuppressWarnings("unchecked")
@SuppressWarnings(value={"unchecked","deprecation"})
```



元注解  注解其他的注解   java定义了四个meta-annotation

@Target   描述注解的使用范围

@Retention  表示需要在什么级别保存该注释信息  描述注解的生命周期

只有这三个 一般在runtime

(SOURCE <CLASS<RUNTIME)

 @Documented    说明该注解将被包含在javadoc中

@Inherited   Inherited 子类可以继承父类的注解

```
public @interface Target {
 
    ElementType[] value();
}
public enum ElementType {
    /** Class, interface (including annotation type), or enum declaration */
    TYPE,

    /** Field declaration (includes enum constants) */
    FIELD,

    /** Method declaration */
    METHOD,

    /** Formal parameter declaration */
    PARAMETER,

    /** Constructor declaration */
    CONSTRUCTOR,

    /** Local variable declaration */
    LOCAL_VARIABLE,

    /** Annotation type declaration */
    ANNOTATION_TYPE,

    /** Package declaration */
    PACKAGE,

    /**
     * Type parameter declaration
     *
     * @since 1.8
     */
    TYPE_PARAMETER,

    /**
     * Use of a type
     *
     * @since 1.8
     */
    TYPE_USE
}
public enum RetentionPolicy {
    /**
     * Annotations are to be discarded by the compiler.
     */
    SOURCE,

    /**
     * Annotations are to be recorded in the class file by the compiler
     * but need not be retained by the VM at run time.  This is the default
     * behavior.
     */
    CLASS,

    /**
     * Annotations are to be recorded in the class file by the compiler and
     * retained by the VM at run time, so they may be read reflectively.
     *
     * @see java.lang.reflect.AnnotatedElement
     */
    RUNTIME
}

```



自定义注解  @interface 



## 反射

java视为动态语言的关键

直接操作任意对象的内部属性及方法

```
Class  aClass = Class.forName("Zhujie.user");
```

获取类名字   

```
user user1 = new user();
System.out.println(user1.getClass().hashCode()); //这个也行 因为所有类都继承object    object里面有getclass

//方式三：通过类名.class获得
        Class c3=Student.class;
        System.out.println(c3.hashCode());
        //方式四：基本内置类型的包装类 都有一个Tpye属性
        Class  type = Integer.TYPE;
        System.out.println(type);
```

![image-20241213214039181](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241213214039181.png)

## 类加载内存分析

类的加载-》类的连接-》类的初始化



![image-20241214154101382](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241214154101382.png)

## 分析类初始化

![image-20241214155439679](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241214155439679.png)

但是加载只会加载一次？



## 类加载器的作用

![image-20241214160913591](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241214160913591.png)

![image-20241214161053446](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241214161053446.png)



## 获取类的结构

```
public class test10 {

    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException {

         Class  c1 = Class.forName("Zhujie.user");

//        user a=new user();
//        Class c1= user.class;
    //获得类的名字
        System.out.println(c1.getName());
        System.out.println(c1.getSimpleName());
        
        //获得类的属性
        System.out.println("===============");
//        Field[] fields = c1.getFields(); //只能找到public属性
//        for (Field f : fields) {
//            System.out.println(f);
//        }


        Field[] declaredFields = c1.getDeclaredFields();
        //能找到全部的属性
        for (Field f : declaredFields) {
            System.out.println(f);
        }


        //Field name = c1.getField("name"); //private属性找不到
        Field name=c1.getDeclaredField("name");
        System.out.println(name);

        //获得类的方法
        Method[] methods = c1.getMethods();//获得本类及其父类的全部public方法 包括object类
        Method[] declaredMethods = c1.getDeclaredMethods();//获得本类的所有方法
        for (Method m : declaredMethods) {
            System.out.println(m);
        }
        System.out.println("=================");

        for (Method m : methods) {
            System.out.println("正常"+m);
        }
        System.out.println("=============");
        //获得指定方法
        Method getName = c1.getMethod("getName", null);
        Method setName=c1.getMethod("setName", String.class);
        System.out.println(getName);
        System.out.println(setName);
        System.out.println("==============");
        //获得构造器
        Constructor[] constructors = c1.getConstructors(); //获得本类及其父类的public方法
        Constructor[] declaredConstructors = c1.getDeclaredConstructors(); //获得本类方法

        for (Constructor c : constructors) {
            System.out.println(c);
        }
        System.out.println("==============");
        for (Constructor c : declaredConstructors) {
            System.out.println(c);
        }


        //获得指定构造器
        Constructor declaredConstructor = c1.getDeclaredConstructor(String.class, int.class, int.class);
        System.out.println("指定"+declaredConstructor);
    }
}
```